#!/usr/bin/python
##############################################################################
#  Copyright (c) 2019 Intel Corporation
# 
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
##############################################################################
#    File Abstract: 
#    Creates a collectd conf file based on command line parametser
#
##############################################################################
import os
import logging
import sys
import traceback
import argparse
import signal

_Version = "12.20.19 Build 1"

logger = logging.getLogger(__name__)

_PluginsConfiguredForUse={} # plugins and config to be written to file

_VerboseLevel = 0

_Cores='[]'
_ConfigDir="config" 
_MainConfigFile=os.path.join(_ConfigDir,"collectd.conf")

_Plugins={} # map of all registered plugins

def getCommentHeader():
    return "### This configuration file automatically generated by launcher tool ###"

### This helper adds the plugin to a big list that is used to create
### the config file.  For pluginhandlers that creat a list of paramters,
### the argList will be a list.  If the plugin does nothing specific
### and lets the user pass settings for parameters, then what is
### passed is a dictionary, and is passed just a bit different
def addConfiguredPlugin(pluginName,argList,duplicateAllowed=False):
    Interval = None
    if not None == argList and 'Interval' in argList: #Interval could be a plugin specific option
        Interval = argList['Interval']
        del argList['Interval']

    if isinstance(argList,list):
        configData = argList
    else:
        configData = handleSpecifiedParams(argList)

    if not pluginName in _PluginsConfiguredForUse or not duplicateAllowed:
        if None == Interval and pluginName in _PluginsConfiguredForUse:
            Interval,_ = _PluginsConfiguredForUse[pluginName]        

        _PluginsConfiguredForUse[pluginName] = (Interval,[])

    _,pluginArgList = _PluginsConfiguredForUse[pluginName]
    
    pluginArgList.extend(configData)

def writePlugins(fp):
    writeLine(fp,"#### Plugins to load ####")
    for pluginName in _PluginsConfiguredForUse:
        interval,_ = _PluginsConfiguredForUse[pluginName] #is a tuple, Interval,and config data
        if None == interval: 
            writeLine(fp,"LoadPlugin " + pluginName)
        else:
            writeLine(fp,"<LoadPlugin " + pluginName +">")
            writeLine(fp,"Interval " + interval)
            writeLine(fp,"</LoadPlugin>")

    writeLine(fp,"\n#### Plugin Configuration ####")
    for pluginName in _PluginsConfiguredForUse:
        for line in _PluginsConfiguredForUse[pluginName][1]: #[0] is the interval
            writeLine(fp,line)

        if len(_PluginsConfiguredForUse[pluginName][1]) > 0:
            writeLine(fp," ")


def processExporterCSV(csvArgs):
    if False == argHasValue(csvArgs,"DataDir"):
        logger.error("CSV exporter specified without DataDir.")
        raise argparse.ArgumentError(None,"CSV exporter specified without DataDir.")
        
    csvConfig=[]
    csvConfig.append('<Plugin "csv">')
    csvConfig.append('DataDir "' + getArgValue(csvArgs,"DataDir","unused") +'"')
    csvConfig.append("StoreRates " + getArgValue(csvArgs,"StoreRates",'false'))
    csvConfig.append("</Plugin>")

    addConfiguredPlugin('csv',csvConfig,csvArgs)

    logger.debug(csvConfig)          

def processExporterNetwork(networkArgs):
    if False == argHasValue(networkArgs,"target"):
        logger.error("Network exporter specified without target.")
        raise argparse.ArgumentError(None,"Network exporter specified without target.")

    target = getArgValue(networkArgs,"target",'unused')

    if not ":" in target or len(target.split(":")) != 2:
        logger.error("Network exporter specified with invalid target: " + target)
        raise argparse.ArgumentError(None,"Network exporter specified with invalid target: " + target)

    ip,port = target.split(":") 

    try:
        _ = int(port)

    except:
        logger.warning("Network exporter specified with possibly invalid target: " + target)
        
    networkConfig=[]

    networkConfig.append('<Plugin "network">')
    networkConfig.append('<Server "' + ip +'" "' + port +'"/>')
    networkConfig.append("</Plugin>")

    addConfiguredPlugin('network',networkConfig,True)

def processExporterKafka(kafkaArgs):
    if False == argHasValue(kafkaArgs,"listenAt"):
        logger.error("write kafka exporter specified without listenAt.")
        raise argparse.ArgumentError(None,"write kafka exporter specified without listenAt.")
        
    kafkaConfig=[]

    kafkaConfig.append('<Plugin "write_kafka">')
    kafkaConfig.append('Property "metadata.broker.list" "' + getArgValue(kafkaArgs,"listenAt",'unused') +'"')
    kafkaConfig.append('<Topic "collectd">')
    kafkaConfig.append("Format " + getArgValue(kafkaArgs,"Format",'JSON'))
    kafkaConfig.append("</Topic>")
    kafkaConfig.append("</Plugin>")

    addConfiguredPlugin('write_kafka',kafkaConfig)


def processExporterAMQP(amqpArgs):
    amqpConfig=[]

    amqpConfig.append('<Plugin amqp>')

    amqpConfig.append('<Publish "' + getArgValue(amqpArgs,"publish","collectd") +'">')
    amqpConfig.append('Host "' + getArgValue(amqpArgs,"Host","localhost") + '"')
    amqpConfig.append('Port "' + getArgValue(amqpArgs,"Port","5672") + '"')
    amqpConfig.append('Vhost "' + getArgValue(amqpArgs,"VHost","/") + '"')
    amqpConfig.append('User "' + getArgValue(amqpArgs,"User","guest") + '"')
    amqpConfig.append('Password "' + getArgValue(amqpArgs,"Password","guest") + '"')
    amqpConfig.append('Exchange "' + getArgValue(amqpArgs,"Exchange","amq.fanout") + '"')
    amqpConfig.append("</Publish>")

    amqpConfig.append("</Plugin>")
    addConfiguredPlugin('ampq',amqpConfig)

def processExporterPrometheus(prometheusArgs):
    if not argHasValue(prometheusArgs,'port'):
        prometheusArgs['Port'] = '9103'

    addConfiguredPlugin('write_prometheus',prometheusArgs)

def processExporterHttp(httpArgs):
    httpConfig=[]

    httpConfig.append('<Plugin "write_http">')
    httpConfig.append('Node "{}">'.format(getArgValue(httpArgs,"node","collectd")))
    if not argHasValue(httpArgs,"url"):
        raise argparse.ArgumentError(None,"http exporter requires URL parameter")

    if argHasValue(httpArgs,"format"):
        httpConfig.append('Format "{}">'.format(getArgValue(httpArgs,"format","JSON")))

    if argHasValue(httpArgs,"User"):
        httpConfig.append('User "{}">'.format(getArgValue(httpArgs,"user","not_specified")))

    if  argHasValue(httpArgs,"Password"):
        httpConfig.append('Password "{}">'.format(getArgValue(httpArgs,"password","not_specified")))

    httpConfig.append("</Node")
    httpConfig.append("</Plugin")    
    addConfiguredPlugin('write_http',httpConfig)

def handleExporters(exporterList):
    exporterHandlerMap={"csv":processExporterCSV,"prometheus":processExporterPrometheus,
                        "kafka": processExporterKafka, "network":processExporterNetwork,
                        "amqp" : processExporterAMQP, "http":processExporterHttp
    }

    for exporter in exporterList:
        parts = exporter.split(",")
        exporterName = parts[0].strip()
        if not exporterName.lower() in exporterHandlerMap:
            logger.critical("Unknown exporter: '{}'".format(exporterName))
            raise argparse.ArgumentError(None,"Unknown exporter: '{}'".format(exporterName))

        exporterArgs={}
        # get args for specific exporter
        for subArg in parts[1:]:
            if not '=' in subArg:
                logger.critical("Unknown exporter '{}' option: {}".format(exporterName,subArg))
                raise argparse.ArgumentError(None,"Unknown exporter: '{}'".format(exporterName))

            key,value=subArg.split("=")
            key = key.strip()
            value = value.strip()
            exporterArgs[key]=value

        exporterHandlerMap[exporterName.lower()](exporterArgs) # call exporter specific function, with parameters


def argHasValue(argList,key):
    normalizedMap={}
    for mapKey in argList:
        normalizedMap[mapKey.lower()] = argList[mapKey]

    if not key.lower() in normalizedMap:
        return False

    return True

def getArgValue(argList,key,defValue):
    normalizedMap={}
    for mapKey in argList:
        normalizedMap[mapKey.lower()] = argList[mapKey]

    if not key.lower() in normalizedMap:
        return defValue

    return normalizedMap[key.lower()]


def handleCustomInterval(arglist,targetList):
    if "interval" in arglist:
        targetList.append("Interval " + arglist["interval"])

def writeLine(fp,data):
    fp.write(data)
    fp.write("\n")

def handlePluginIntelPMU(argList):
    pmuConfig=[]

    pmuConfig.append('<Plugin "intel_pmu">')
    pmuConfig.append("ReportHardwareCacheEvents " + getArgValue(argList,"ReportHardwareCacheEvents",'true'))
    pmuConfig.append("ReportKernelPMUEvents " + getArgValue(argList,"ReportKernelPMUEvents",'true'))
    pmuConfig.append("ReportSoftwareEvents " + getArgValue(argList,"ReportSoftwareEvents",'true'))
    pmuConfig.append('Cores "' + getArgValue(argList,"Cores",_Cores) + '"')
    pmuConfig.append("</Plugin>")

    addConfiguredPlugin('intel_pmu',pmuConfig)

def handlePluginIntelRDT(argList):
    rdtConfig=[]

    rdtConfig.append('<Plugin "intel_rdt">')
    rdtConfig.append('Cores "' + getArgValue(argList,"Cores",_Cores) + '"')
    rdtConfig.append("</Plugin>")

    addConfiguredPlugin('intel_rdt',rdtConfig)

def handleSpecifiedParams(argList):
    returnArgs=[]

    if None != argList:
        for arg in argList:
            if isinstance(argList[arg],list):
                for argInst in argList[arg]: # is a list of the same thing (like Instance in netlink plugin)
                    returnArgs.append('{} "{}"'.format(arg,argInst))

            else:
                returnArgs.append('{} "{}"'.format(arg,argList[arg]))

    return returnArgs

def handlePluginCpufreq(argList):
    addConfiguredPlugin('cpufreq',argList)

def handlePluginCpu(argList):
    addConfiguredPlugin('cpu',argList)

def handlePluginDisk(argList):
    addConfiguredPlugin('disk',argList)

def handlePluginEthstat(argList):
    addConfiguredPlugin('ethstat',argList)

def handlePluginIpc(argList):
    addConfiguredPlugin('ipc',argList)

def handlePluginIpmi(argList):
    addConfiguredPlugin('ipmi',argList)

def handlePluginLoad(argList):
    addConfiguredPlugin('load',argList)

def handlePluginMemory(argList):
    addConfiguredPlugin('memory',argList)

def handlePluginNuma(argList):
    addConfiguredPlugin('numa',argList)

def handlePluginProcesses(argList):
    addConfiguredPlugin('processes',argList)

def handlePluginDf(argList):
    addConfiguredPlugin('df',argList)

def handlePluginTurbostat(argList):
    addConfiguredPlugin('turbostat',argList)

def handlePluginNetlink(argList):
    addConfiguredPlugin('netlink',argList)

def handlePluginUptime(argList):
    addConfiguredPlugin('uptime',argList)

def handlePluginContextswitch(argList):
    addConfiguredPlugin('contextswitch',argList)

def handlePluginIrq(argList):
    addConfiguredPlugin('irq',argList)

def handlePluginSwap(argList):
    addConfiguredPlugin('swap',argList)

def handlePluginPcieErrors(argList):
    addConfiguredPlugin('pcie_errors',argList)        

def handlePluginDpdkStat(argList):
    if not argHasValue(argList,'enabledportmask'):
        argList['EnablePortMask'] = '0xffff'

    addConfiguredPlugin('dpdkstat',argList)        

def handlePluginOvsStats(argList):
    addConfiguredPlugin('ovs_stats',argList)        

def handlePluginOvsEvents(argList):
    addConfiguredPlugin('ovs_events',argList)        

class ArgParser(object):
    def __init__(self):
        parser = argparse.ArgumentParser(description='launcher - launcher for collectd.', usage='''-x exporter(s) [other options] -- test [test options] 
expoerters are:
   csv          write data to csv file
        ex: -x csv,DataDir=/var/collectd
   network      sends to a network port + ip
        ex: -x network,target=ip:port
   kafka       
        ex: -x kafka,listenAt=ip:port[,format='JSON']
   ampq    
        ex: -x ampq,publish=name,host=target,port=targetPort


tests are:
   standard     General set  of useful telemetry
   debug        standard telemetry with additional stuff to help find issues
   custom       you specify everything
''')

        parser.add_argument("-v","--verbose",help="prints information, values 0-3",type=int,default=0)
        parser.add_argument("-x","--exporter",default=[],type=str,action='append',required=True)
        parser.add_argument("-i","--interval",default=60,type=int )
        parser.add_argument("--testonly",type=bool,default=False)
        parser.add_argument("--hostname",type=str)
        parser.add_argument("-t","--type",type=str,default=[],action='append')

        argList = self.cleanUpArgs()

        self.globalArgs=[]
        self.actionArgs=[]

        if len(argList) < 2:
            print("Error: too short")
            raise argparse.ArgumentError(None,"too short")

        for index,arg in enumerate(argList):
            if not '--' == arg:
                self.globalArgs.append(arg)
                
            else:
                self.actionArgs.extend(argList[index+1:])
                break

        try:
            args = parser.parse_args(self.globalArgs)
            if None == args.verbose:
                _VerboseLevel = 0
            else:
                _VerboseLevel = args.verbose

            if _VerboseLevel == 0:
                logLevel = logging.ERROR

            elif _VerboseLevel == 1:
                logLevel = logging.WARNING

            elif _VerboseLevel == 2:
                logLevel = logging.INFO

            elif _VerboseLevel > 2:
                logLevel = logging.DEBUG

            logging.basicConfig(level=logLevel)
            logger = logging.getLogger(__name__)

            if not os.path.isdir(_ConfigDir):
                os.mkdir(_ConfigDir)

            handleExporters(args.exporter)

            for telemetryType in args.type:
                if not(hasattr(self, telemetryType.lower())):
                    logger.error("{} is not a valid option.".format(telemetryType))
                    return
                try:
                    getattr(self, telemetryType.lower())(self.actionArgs)

                except Exception as ex:
                    logger.error(str(ex))
                    return

        except Exception as ex:
            return

        with open(_MainConfigFile,"w") as fp:
            writeLine(fp,getCommentHeader())
            if None != args.hostname:
                writeLine(fp,'Hostname "' + args.hostname +'"')
            else:
                writeLine(fp,'#Hostname ""') # just so they know they didnt' specify anything

            writeLine(fp,"Interval " + str(args.interval))

            writePlugins(fp)

        try:
            if args.testonly:
                launchStr = "/opt/collectd/sbin/collectd -f -C {} -T".format(_MainConfigFile)
            else:
                launchStr = "/opt/collectd/sbin/collectd -f -C {}".format(_MainConfigFile)
            
            logger.debug("Starting Collectd: " + launchStr)
            os.system(launchStr)

        except:
            pass

    def cleanUpArgs(self):
        allArgString=""
        for arg in sys.argv[1:]:
            allArgString += arg +" "

        allArgString = allArgString.strip() # get rid of last space

        while ", " in allArgString:
            allArgString = allArgString.replace(", ",",")

        while " ," in allArgString:
            allArgString = allArgString.replace(" ,",",")

        while "= " in allArgString:
            allArgString = allArgString.replace("= ","=")

        while " =" in allArgString:
            allArgString = allArgString.replace(" =","=")

        argList = allArgString.split(" ")

        return argList

    def executePlugins(self,which,argList):
        for pluginKey in _Plugins[which]:
            handlerFn,params = _Plugins[which][pluginKey]
            handlerFn(params)

    def standard(self,argList):
        self.executePlugins('standard',argList)

    def cpu(self,argList):
        self.executePlugins('cpu',argList)

    def dpdk(self,argList):
        self.executePlugins('dpdk',argList)

    def ovs(self,argList):
        self.executePlugins('ovs',argList)

    def custom(self,argList):
        global _Plugins
        
        for requestdPlugin in argList:
            if ',' in requestdPlugin: #parameters passed for plugin
                parts=requestdPlugin.split(',')
                name=parts[0]

                name = parts[0].strip()

                Args={}
                # get args for specific exporter
                for subArg in parts[1:]:
                    if not '=' in subArg:
                        logger.critical("Invalid formed custom '{}'".format(requestdPlugin))
                        raise argparse.ArgumentError(None,"Invalid formed custom '{}'".format(requestdPlugin))

                    key,value=subArg.split("=")
                    key = key.strip()
                    value = value.strip()
                    Args[key]=value                

            else:
                name = requestdPlugin
                Args = {}

            pluginFn = None

            for pluginGroup in _Plugins:
                if name.lower() in _Plugins[pluginGroup]:
                    pluginFn,defaultParams = _Plugins[pluginGroup][name.lower()]


            if None == pluginFn:
                logger.error("Unknown custom collector: " + name)  
                raise argparse.ArgumentError(None,"Unknown custom collector: " + name) 

            if None != defaultParams and len(Args) == 0:
                Args = defaultParams

            pluginFn(Args)
        pass


def setupPlugins():
    StandardPlugins={
        "disk":(handlePluginDisk,None),
        "pcie_errors":(handlePluginPcieErrors,{"Interval": "0.01"}),
        "cpu":(handlePluginCpu,None),
        "ethstat":(handlePluginEthstat,None),
        "ipmi":(handlePluginIpmi,None),
        "load":(handlePluginLoad,None),
        "memory":(handlePluginMemory,None),
        "processes":(handlePluginProcesses,None),
        "df":(handlePluginDf,None),
        "turbostat":(handlePluginTurbostat,None),
        "uptime":(handlePluginUptime,None),
        "contextswitch":(handlePluginContextswitch,None),
        "irq":(handlePluginIrq,None),
        "swap":(handlePluginSwap,None),
        "netlink":(handlePluginNetlink,None),
        }

    CpuPlugins={
        "cpufreq":(handlePluginCpufreq,None),
        "cpu":(handlePluginCpu,None),
        "ipc":(handlePluginIpc,None),
        "numa":(handlePluginNuma,None),
        "turbostat":(handlePluginTurbostat,None),
        "contextswitch":(handlePluginContextswitch,None),
        "irq":(handlePluginIrq,None),
        "intel_pmu":(handlePluginIntelPMU,
                        {"ReportHardwareCacheEvents":"true","ReportKernelPMUEvents":"false"}
                    ),
        "intel_rdt":(handlePluginIntelRDT,
                        {"Cores":''}
                    ),
                   
        }

    DpdkPlugins={
        "dpdk_stats":(handlePluginDpdkStat,None),
        }

    OvsPlugins={
        "ovs_stats":(handlePluginOvsStats,None),
        "ovs_events":(handlePluginOvsEvents,None),
        }

    notPartOfGroupPlugins={}
        

    global _Plugins
    _Plugins['standard'] = StandardPlugins
    _Plugins['cpu'] = CpuPlugins
    _Plugins['dpdk'] = DpdkPlugins
    _Plugins['ovs'] = OvsPlugins
    _Plugins['other'] =notPartOfGroupPlugins




def main():
    setupPlugins()
    ArgParser()



if __name__ == "__main__":
   try:
      main()

   except Exception as ex:
        logger.critical("Uncaught error: " + str(ex))


   


