#!/usr/bin/python
##############################################################################
#  Copyright (c) 2019 Intel Corporation
# 
# Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
##############################################################################
#    File Abstract: 
#    Creates a collectd conf file based on command line parametser
#
##############################################################################
import os
import logging
import sys
import traceback
import argparse
import signal

_Version = "12.30.19 Build 1"

logger = logging.getLogger(__name__)

_PluginsConfiguredForUse={} # plugins and config to be written to file

_VerboseLevel = 0

_Cores='[]'
_ConfigDir="config" 
_MainConfigFile=os.path.join(_ConfigDir,"collectd.conf")

_Plugins={} # map of all registered plugins
_exporterHandlerMap={} # map of exporters



#### Helper Functions

def getCommentHeader():
    return "### This configuration file automatically generated by launcher tool ###"

### This helper adds the plugin to a big list that is used to create
### the config file.  For pluginhandlers that creat a list of paramters,
### the argList will be a list.  If the plugin does nothing specific
### and lets the user pass settings for parameters, then what is
### passed is a dictionary, and is passed just a bit different
def addConfiguredPlugin(pluginName,argList,duplicateAllowed=False):
    Interval = None
    if not None == argList and 'Interval' in argList: #Interval could be a plugin specific option
        Interval = argList['Interval']
        del argList['Interval']

    if isinstance(argList,list):
        configData = argList
    else:
        configData=[]
        configData.append('<Plugin "{}">'.format(pluginName))
        configData.extend(handleSpecifiedParams(argList))
        configData.append('</Plugin>')

    if not pluginName in _PluginsConfiguredForUse or not duplicateAllowed:
        if None == Interval and pluginName in _PluginsConfiguredForUse:
            Interval,_ = _PluginsConfiguredForUse[pluginName]        

        _PluginsConfiguredForUse[pluginName] = (Interval,[])

    _,pluginArgList = _PluginsConfiguredForUse[pluginName]
    
    pluginArgList.extend(configData)

def writePlugins(fp,testonly):
    writeLine(fp,"#### Plugins to load ####")
    for pluginName in _PluginsConfiguredForUse:
        interval,_ = _PluginsConfiguredForUse[pluginName] #is a tuple, Interval,and config data
        if None == interval: 
            writeLine(fp,"LoadPlugin " + pluginName)
        else:
            writeLine(fp,"<LoadPlugin " + pluginName +">")
            writeLine(fp,"Interval " + interval)
            writeLine(fp,"</LoadPlugin>")

    writeLine(fp,"\n#### Plugin Configuration ####")
    for pluginName in _PluginsConfiguredForUse:
        for line in _PluginsConfiguredForUse[pluginName][1]: #[0] is the interval
            writeLine(fp,line)

        if len(_PluginsConfiguredForUse[pluginName][1]) > 0:
            writeLine(fp," ")

def removeArg(argList,key):
    for mapKey in argList:
        if mapKey.lower() == key.lower():
            del(argList[mapKey])
            break

    #return argList


def argHasValue(argList,key):
    normalizedMap={}
    for mapKey in argList:
        normalizedMap[mapKey.lower()] = argList[mapKey]

    if not key.lower() in normalizedMap:
        return False

    return True

def getArgValue(argList,key,defValue):
    if None == argList:
        return defValue

    normalizedMap={}
    for mapKey in argList:
        normalizedMap[mapKey.lower()] = argList[mapKey]

    if not key.lower() in normalizedMap:
        return defValue

    return normalizedMap[key.lower()]

def handleCustomInterval(arglist,targetList):
    if "interval" in arglist:
        targetList.append("Interval " + arglist["interval"])

def writeLine_toFile(fp,data):
    fp.write(data)
    fp.write("\n")

def writeLine_toTerminal(fp,data):
    print(data)
    writeLine_toFile(fp,data)

def getPhysicalNics():
    retList=[]
    try:
        for nicName in os.listdir('/sys/class/net/'):
            if os.path.isdir('/sys/class/net/' + nicName +'/device'):
                retList.append(nicName)
    except:
        retList=['eth0','eth1','nic1'] # just for testing on my windows box

    return retList

### Exporter Handlers

def processExporterCSV(csvArgs):
    if False == argHasValue(csvArgs,"DataDir"):
        logger.error("CSV exporter specified without DataDir.")
        raise argparse.ArgumentError(None,"CSV exporter specified without DataDir.")
        
    csvConfig=[]
    csvConfig.append('<Plugin "csv">')
    csvConfig.append('DataDir "' + getArgValue(csvArgs,"DataDir","unused") +'"')
    csvConfig.append("StoreRates " + getArgValue(csvArgs,"StoreRates",'false'))
    csvConfig.append("</Plugin>")

    addConfiguredPlugin('csv',csvConfig,csvArgs)

def processExporterNetwork(networkArgs):
    if False == argHasValue(networkArgs,"target"):
        logger.error("Network exporter specified without target.")
        raise argparse.ArgumentError(None,"Network exporter specified without target.")

    target = getArgValue(networkArgs,"target",'unused')

    if not ":" in target or len(target.split(":")) != 2:
        logger.error("Network exporter specified with invalid target: " + target)
        raise argparse.ArgumentError(None,"Network exporter specified with invalid target: " + target)

    ip,port = target.split(":") 

    try:
        _ = int(port)

    except:
        logger.warning("Network exporter specified with possibly invalid target: " + target)
        
    networkConfig=[]

    networkConfig.append('<Plugin "network">')
    #networkConfig.append('    Server "' + ip +'" "' + port +'"')
    networkConfig.append('<Server "' + ip +'" "' + port +'">')
    networkConfig.append("</Server>")
    networkConfig.append("</Plugin>")

    addConfiguredPlugin('network',networkConfig,True)

def processExporterKafka(kafkaArgs):
    if False == argHasValue(kafkaArgs,"listenAt"):
        logger.error("write kafka exporter specified without listenAt.")
        raise argparse.ArgumentError(None,"write kafka exporter specified without listenAt.")
        
    kafkaConfig=[]

    kafkaConfig.append('<Plugin "write_kafka">')
    kafkaConfig.append('Property "metadata.broker.list" "' + getArgValue(kafkaArgs,"listenAt",'unused') +'"')
    kafkaConfig.append('<Topic "collectd">')
    kafkaConfig.append("Format " + getArgValue(kafkaArgs,"Format",'JSON'))
    kafkaConfig.append("</Topic>")
    kafkaConfig.append("</Plugin>")

    addConfiguredPlugin('write_kafka',kafkaConfig)


def processExporterAMQP(amqpArgs):
    amqpConfig=[]

    amqpConfig.append('<Plugin amqp>')

    amqpConfig.append('<Publish "' + getArgValue(amqpArgs,"publish","collectd") +'">')
    amqpConfig.append('Host "' + getArgValue(amqpArgs,"Host","localhost") + '"')
    amqpConfig.append('Port "' + getArgValue(amqpArgs,"Port","5672") + '"')
    amqpConfig.append('Vhost "' + getArgValue(amqpArgs,"VHost","/") + '"')
    amqpConfig.append('User "' + getArgValue(amqpArgs,"User","guest") + '"')
    amqpConfig.append('Password "' + getArgValue(amqpArgs,"Password","guest") + '"')
    amqpConfig.append('Exchange "' + getArgValue(amqpArgs,"Exchange","amq.fanout") + '"')
    amqpConfig.append("</Publish>")

    amqpConfig.append("</Plugin>")
    addConfiguredPlugin('amqp',amqpConfig)

def processExporterPrometheus(prometheusArgs):
    if not argHasValue(prometheusArgs,'port'):
        prometheusArgs['Port'] = '9103'

    addConfiguredPlugin('write_prometheus',prometheusArgs)

def processExporterHttp(httpArgs):
    httpConfig=[]

    print(httpArgs)
    httpConfig.append('<Plugin "write_http">')
    httpConfig.append('<Node "{}">'.format(getArgValue(httpArgs,"node","collectd")))
    if not argHasValue(httpArgs,"url"):
        raise argparse.ArgumentError(None,"http exporter requires URL parameter")
        
    httpConfig.append('URL "{}"'.format(getArgValue(httpArgs,"url","")))    

    if argHasValue(httpArgs,"format"):
        httpConfig.append('Format "{}"'.format(getArgValue(httpArgs,"format","JSON")))

    if argHasValue(httpArgs,"User"):
        httpConfig.append('User "{}"'.format(getArgValue(httpArgs,"user","not_specified")))

    if  argHasValue(httpArgs,"Password"):
        httpConfig.append('Password "{}"'.format(getArgValue(httpArgs,"password","not_specified")))
        
    if argHasValue(httpArgs,"Header"):
        httpConfig.append('Header "{}"'.format(getArgValue(httpArgs,"Header","")))
        
    if argHasValue(httpArgs,"VerifyPeer"):
        httpConfig.append('VerifyPeer "{}"'.format(getArgValue(httpArgs,"VerifyPeer","false")))

    if argHasValue(httpArgs,"VerifyHost"):
        httpConfig.append('VerifyHost "{}"'.format(getArgValue(httpArgs,"VerifyHost","false")))
        
    httpConfig.append("</Node>")
    httpConfig.append("</Plugin>")    
    addConfiguredPlugin('write_http',httpConfig)
    print(httpConfig)

def handleExporters(exporterList):
    for exporter in exporterList:
        parts = exporter.split(",")
        exporterName = parts[0].strip()
        if not exporterName.lower() in _exporterHandlerMap:
            logger.critical("Unknown exporter: '{}'".format(exporterName))
            raise argparse.ArgumentError(None,"Unknown exporter: '{}'".format(exporterName))

        exporterArgs={}
        # get args for specific exporter
        for subArg in parts[1:]:
            if not '=' in subArg:
                logger.critical("Unknown exporter '{}' option: {}".format(exporterName,subArg))
                raise argparse.ArgumentError(None,"Unknown exporter: '{}'".format(exporterName))

            key,value=subArg.split("=")
            key = key.strip()
            value = value.strip()
            exporterArgs[key]=value

        exporterFn,_ = _exporterHandlerMap[exporterName.lower()]

        exporterFn(exporterArgs) # call exporter specific function, with parameters

#### Collector writers
def handlePluginIntelPMU(argList):
    pmuConfig=[]

    pmuConfig.append('<Plugin "intel_pmu">')
    pmuConfig.append("ReportHardwareCacheEvents " + getArgValue(argList,"ReportHardwareCacheEvents",'true'))
    pmuConfig.append("ReportKernelPMUEvents " + getArgValue(argList,"ReportKernelPMUEvents",'true'))
    pmuConfig.append("ReportSoftwareEvents " + getArgValue(argList,"ReportSoftwareEvents",'true'))
    pmuConfig.append('Cores "' + getArgValue(argList,"Cores",_Cores) + '"')
    pmuConfig.append("</Plugin>")

    addConfiguredPlugin('intel_pmu',pmuConfig)

def handlePluginIntelRDT(argList):
    rdtConfig=[]

    rdtConfig.append('<Plugin "intel_rdt">')
    rdtConfig.append('Cores "' + getArgValue(argList,"Cores",_Cores) + '"')
    rdtConfig.append("</Plugin>")

    addConfiguredPlugin('intel_rdt',rdtConfig)

def handleSpecifiedParams(argList):
    returnArgs=[]

    if None != argList:
        for arg in argList:
            if isinstance(argList[arg],list):
                for argInst in argList[arg]: # is a list of the same thing (like Instance in netlink plugin)
                    returnArgs.append('{} "{}"'.format(arg,argInst))

            else:
                returnArgs.append('{} "{}"'.format(arg,argList[arg]))

    return returnArgs

def handlePluginCpufreq(argList):
    addConfiguredPlugin('cpufreq',argList)

def handlePluginCpu(argList):
    addConfiguredPlugin('cpu',argList)

def handlePluginDisk(argList):
    addConfiguredPlugin('disk',argList)

def handlePluginEthstat(argList):
    if 'true' == getArgValue(argList,"all_physical_nics",'false'):
        nicList = getPhysicalNics()
        removeArg(argList,"all_physical_nics")
        argList['Interface'] = nicList

    addConfiguredPlugin('ethstat',argList)

def handlePluginIpc(argList):
    addConfiguredPlugin('ipc',argList)

def handlePluginIpmi(argList):
    addConfiguredPlugin('ipmi',argList)

def handlePluginLoad(argList):
    addConfiguredPlugin('load',argList)

def handlePluginMemory(argList):
    addConfiguredPlugin('memory',argList)

def handlePluginNuma(argList):
    addConfiguredPlugin('numa',argList)

def handlePluginProcesses(argList):
    addConfiguredPlugin('processes',argList)

def handlePluginDf(argList):
    addConfiguredPlugin('df',argList)

def handlePluginTurbostat(argList):
    addConfiguredPlugin('turbostat',argList)

def handlePluginNetlink(argList):
    if 'true' == getArgValue(argList,"all_physical_nics",'false'):
        nicList = getPhysicalNics()
        removeArg(argList,"all_physical_nics")
        argList['Interface'] = nicList

    addConfiguredPlugin('netlink',argList)

def handlePluginUptime(argList):
    addConfiguredPlugin('uptime',argList)

def handlePluginContextswitch(argList):
    addConfiguredPlugin('contextswitch',argList)

def handlePluginIrq(argList):
    addConfiguredPlugin('irq',argList)

def handlePluginSwap(argList):
    addConfiguredPlugin('swap',argList)

def handlePluginPcieErrors(argList):
    addConfiguredPlugin('pcie_errors',argList)        

def handlePluginDpdkStat(argList):
    if not argHasValue(argList,'enabledportmask'):
        argList['EnablePortMask'] = '0xffff'

    addConfiguredPlugin('dpdkstat',argList)        

def handlePluginOvsStats(argList):
    addConfiguredPlugin('ovs_stats',argList)        

def handlePluginOvsEvents(argList):
    addConfiguredPlugin('ovs_events',argList)        

def genericPlugin(name,argList):
    addConfiguredPlugin(name,argList)


class ArgParser(object):
    def __init__(self):
        parser = argparse.ArgumentParser(description='launcher - launcher for collectd.', usage='''-x exporter(s) [other options] -- t [which 'group' of collectors to use] 
expoerters are:
   csv          write data to csv file
        ex: -x csv,DataDir=/var/collectd
   network      sends to a network port + ip
        ex: -x network,target=ip:port
   kafka       
        ex: -x kafka,listenAt=ip:port[,format='JSON']
   amqp    
        ex: -x amqp,publish=name,host=target,port=targetPort


groups are:
   standard     General set  of useful telemetry 
   network      ethstat and netlink plugins
   cpu          more details on cpu stats
   ovs          ovs stats
   dpdk         dpdk information
''')

        parser.add_argument("-v","--verbose",help="prints information, values 0-3",type=int,default=0)
        parser.add_argument("-x","--exporter",default=[],type=str,action='append',required=True)
        parser.add_argument("-i","--interval",default=60,type=int )
        parser.add_argument("--hostname",type=str)
        parser.add_argument("-t","--type",type=str,default=[],action='append')
        parser.add_argument("--list_plugins",help="print all of the plugins currently supported",action='store_true')
        parser.add_argument("--testonly",help="Generates config file and attempts to load it, then exits.",action='store_true')

        argList = self.cleanUpArgs()

        self.globalArgs=[]
        self.actionArgs=[]

        for index,arg in enumerate(argList):
            if not '--' == arg:
                self.globalArgs.append(arg)

                if arg.lower() == '--list_plugins':
                    listAllKnownPlugins()
                    return
                
            else:
                self.actionArgs.extend(argList[index+1:])
                break

        try:
            print(self.globalArgs)
            args = parser.parse_args(self.globalArgs)
            
            if None == args.verbose:
                _VerboseLevel = 0
            else:
                _VerboseLevel = args.verbose

            if _VerboseLevel == 0:
                logLevel = logging.ERROR

            elif _VerboseLevel == 1:
                logLevel = logging.WARNING

            elif _VerboseLevel == 2:
                logLevel = logging.INFO

            elif _VerboseLevel > 2:
                logLevel = logging.DEBUG

            logging.basicConfig(level=logLevel)
            logger = logging.getLogger(__name__)

            if args.testonly:  # only going to test, so don't write to file, just print it out instead :-)
                global writeLine
                writeLine = writeLine_toTerminal

            if not os.path.isdir(_ConfigDir):
                os.mkdir(_ConfigDir)

            handleExporters(args.exporter)

            for telemetryType in args.type:
                if not(hasattr(self, telemetryType.lower())):
                    logger.error("{} is not a valid option.".format(telemetryType))
                    return
                try:
                    getattr(self, telemetryType.lower())(self.actionArgs)

                except Exception as ex:
                    logger.error(str(ex))
                    return

        except Exception as ex:
            return

        with open(_MainConfigFile,"w") as fp:
            writeLine(fp,getCommentHeader())
            if None != args.hostname:
                writeLine(fp,'Hostname "' + args.hostname +'"')
            else:
                writeLine(fp,'#Hostname ""') # just so they know they didnt' specify anything

            writeLine(fp,"Interval " + str(args.interval))

            writePlugins(fp,args.testonly)

        try:
            if args.testonly:
                launchStr = "/opt/collectd/sbin/collectd -f -C {} -T".format(_MainConfigFile)
            else:
                launchStr = "/opt/collectd/sbin/collectd -f -C {}".format(_MainConfigFile)
            
            logger.debug("Starting Collectd: " + launchStr)
            os.system(launchStr)

        except:
            pass

    def cleanUpArgs(self):
        allArgString=""
        Token = "__SPLIT_TOKEN__"
        for arg in sys.argv[1:]:
            allArgString += arg + Token

        allArgString = allArgString.strip() # get rid of last space
        
        while ", " in allArgString:
            allArgString = allArgString.replace(", ",",")

        while " ," in allArgString:
            allArgString = allArgString.replace(" ,",",")

        while "= " in allArgString:
            allArgString = allArgString.replace("= ","=")

        while " =" in allArgString:
            allArgString = allArgString.replace(" =","=")

        argList = allArgString.split(Token)

        retList = []
        # can get empty items in the list, and argparse does not like that
        for arg in argList:
            if len(arg) > 0:
                retList.append(arg)

        return retList

    def executePlugins(self,which,argList):
        for pluginKey in _Plugins[which]:
            handlerFn,params,_ = _Plugins[which][pluginKey]
            handlerFn(params)

    def standard(self,argList):
        self.executePlugins('standard',argList)

    def network(self,argList):
        self.executePlugins('network',argList)

    def cpu(self,argList):
        self.executePlugins('cpu',argList)

    def dpdk(self,argList):
        self.executePlugins('dpdk',argList)

    def ovs(self,argList):
        self.executePlugins('ovs',argList)

    def custom(self,argList):
        global _Plugins
        
        for requestdPlugin in argList:
            if ',' in requestdPlugin: #parameters passed for plugin
                parts=requestdPlugin.split(',')
                name=parts[0]

                name = parts[0].strip()

                Args={}
                # get args for specific exporter
                for subArg in parts[1:]:
                    if not '=' in subArg:
                        logger.warn("Invalid formed custom '{}'".format(requestdPlugin))
                        raise argparse.ArgumentError(None,"Invalid formed custom '{}'".format(requestdPlugin))

                    key,value=subArg.split("=")
                    key = key.strip()
                    value = value.strip()
                    Args[key]=value                

            else:
                name = requestdPlugin
                Args = {}

            pluginFn = None

            for pluginGroup in _Plugins:
                if name.lower() in _Plugins[pluginGroup]:
                    pluginFn,defaultParams,_ = _Plugins[pluginGroup][name.lower()]

                    if None != defaultParams and len(Args) == 0:
                        Args = defaultParams

                    pluginFn(Args)

            # what was specified was not one for which there is a specific funtion to handle, so just try it
            if None == pluginFn:
                logger.warning("Unknown custom collector [{}] specified.  Attempting to configure.".format(name))  
                genericPlugin(name,Args) 


def setupPlugins():
    ### the plugins are arranged in a dictionary of 'plugin name':tuple(pluginHandlerFn,defaultArgs,CustomHelpString)
    ### Some have some default parameters that can be overwritten if they use -t custom
    StandardPlugins={
        "disk":(handlePluginDisk,None,None),
        "pcie_errors":(handlePluginPcieErrors,{"Interval": "0.01"},None),
        "cpu":(handlePluginCpu,None,None),
        "ethstat":(handlePluginEthstat,{"all_physical_nics":"true"},"all_physical_nics=true - if set, will gather stats for all real nics"),
        "ipmi":(handlePluginIpmi,None,None),
        "load":(handlePluginLoad,None,None),
        "memory":(handlePluginMemory,None,None),
        "processes":(handlePluginProcesses,None,None),
        "df":(handlePluginDf,None,None),
        "turbostat":(handlePluginTurbostat,None,None), 
        # "uptime":(handlePluginUptime,None),        # doesn't seem to have the plugin in current docker build
        # "contextswitch":(handlePluginContextswitch,None),  # doesn't seem to have the plugin in current docker build
        "irq":(handlePluginIrq,None,None),
        "swap":(handlePluginSwap,None,None),
        "netlink":(handlePluginNetlink,{"all_physical_nics":"true"},"all_physical_nics=true - if set, will gather stats for all real nics"),
        }

    CpuPlugins={
        "cpufreq":(handlePluginCpufreq,None,None),
        "cpu":(handlePluginCpu,None,None),
        "ipc":(handlePluginIpc,None,None),
        "numa":(handlePluginNuma,None,None),
        "turbostat":(handlePluginTurbostat,None,None),
        "contextswitch":(handlePluginContextswitch,None,None),
        "irq":(handlePluginIrq,None,None),
        "intel_pmu":(handlePluginIntelPMU,
                        {"ReportHardwareCacheEvents":"true","ReportKernelPMUEvents":"false"},None
                    ),
        "intel_rdt":(handlePluginIntelRDT,
                        {"Cores":''},None
                    ),
        }

    NetworkPlugins={
        "ethstat":(handlePluginEthstat,{"all_physical_nics":"true"},"all_physical_nics=true - if set, will gather stats for all real nics"),
        "netlink":(handlePluginNetlink,{"all_physical_nics":"true"},"all_physical_nics=true - if set, will gather stats for all real nics"),
    }

    DpdkPlugins={
        "dpdk_stats":(handlePluginDpdkStat,None,None),
        }

    OvsPlugins={
        "ovs_stats":(handlePluginOvsStats,None,None),
        "ovs_events":(handlePluginOvsEvents,None,None),
        }

    notPartOfGroupPlugins={}

    global _Plugins
    _Plugins['standard'] = StandardPlugins
    _Plugins['cpu'] = CpuPlugins
    _Plugins['dpdk'] = DpdkPlugins
    _Plugins['ovs'] = OvsPlugins
    _Plugins['not grouped'] = notPartOfGroupPlugins
    _Plugins['network'] = NetworkPlugins

    global _exporterHandlerMap
    _exporterHandlerMap={"csv": (processExporterCSV,None),
                        "prometheus": (processExporterPrometheus,None),
                        "kafka": (processExporterKafka,None), 
                        "network":(processExporterNetwork,"target=ip:port"),
                        "amqp" : (processExporterAMQP,"publish='name' [default=collectd], all others standard for amqp plugin"), 
                        "http": (processExporterHttp,"node='name', all others standard for http_write")
    }


# overwriteable function to write to file, or print then write to file
writeLine = writeLine_toFile

def listAllKnownPlugins():
    print("Plugins for which support is explicitly added:")
    print("Test Group\tPlugin Name\tCustom Options")
    for pluginName in sorted(_Plugins.keys()):
        if 'not grouped' == pluginName:
            continue

        print("{}".format(pluginName))
        for collectorName in sorted(_Plugins[pluginName].keys()):
            _,_,customArgs = _Plugins[pluginName][collectorName]
            if None == customArgs:
                customArgs=""
            print("\t\t{}\t\t{}".format(collectorName,customArgs))


    print("\nExporters Supported:")
    print("Name\t\tCustom Options")
    for exporter in sorted(_exporterHandlerMap.keys()):
        _,customArgs = _exporterHandlerMap[exporter]
        if None == customArgs:
            customArgs = "See collectd documentation"
        print(" {}\t\t\t{}".format(exporter,customArgs))


def main():
    setupPlugins()
    ArgParser()

if __name__ == "__main__":
   try:
      main()

   except Exception as ex:
        logger.critical("Uncaught error: " + str(ex))


   


